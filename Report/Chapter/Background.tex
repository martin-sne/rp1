\section{Background}
\label{chap:background}
\subsection{SNMP}
SNMP is an IETF (Internet Engineering Task Force) Internet Standard to manage and monitor devices running on IP networks and is defined in several RFC's \cite{snmp-rfc}. SNMP is a connectionless protocol using UDP Port 161. SNMP provides an abstract interface to serve status information about IP capable devices or applications to a management station. Classical candidates that support SNMP are network devices such as routers and switches. SNMP can also be implemented on Operating Systems or application extensions. 
\\
SNMP provides an agent-manager architecture. The agent facilitates an SNMP interface that allows a manager to get (or sometimes set) management information data from a managed device in an SNMP-specific form.
The \q{set} facilities never made it to real-life use because of its limited security and that is also the main reason why SNMP is only used in \q{get} mode. Other protocols seem to be leading the “set” aspect. For example one could use IPsec, or might send SNMP over SCTP to have an additional protection layer to circumvent the insecurity of the SNMP protocol. Version 3 of the SNMP protocol includes authentication, privacy, and access control \cite{cisco-snmp}. 
 \\
An agent can be implemented as a subagent that registers data to a master agent by using the AgentX protocol \cite{agentx}. The structure of the management information and available SNMP variables are defined in a Management Information Base (MIB) which follows strict syntax rules defined in the Structure of Management Information Version 2 (SMIv2) \cite{smiv2}. SMIv2 is a subset of ASN.1. 
\\
SNMP variables are assigned to Object Identifiers (OID) and organized in a hierarchical structure. Before writing an SNMP MIB, an OID entry point inside the global MIB tree has to be defined. Those entry points are located under the internet branch \cite{oid1}. Public branches  inside the \textit{mgmt} subtree are defined by the IETF. Private branches inside the \textit{private} subtree are assigned to companies by the Internet Assigned Numbers Authority (IANA). An OID requires to be unique to avoid overlapping with other MIBs. An \textit{experimental} subtree exists for testing purposes.

\subsection{DNSSEC}
DNS stands for Domain Name System. It is a decentralized hierarchical distributed system that mainly translates domain names to IP addresses. As DNS does not provide integrity nor authentication, DNS data can be subject to forgery. Hence, DNSSEC has been specified to solve this problem. It uses public key cryptography and cryptographically signs the resource records of a zone so a chain of trust can be build from the root down.
To understand the concept of this chain of trust, let's walk it from bottom up, with \textit{derby.os3.nl.} as a zone example. 
\\
First of all, the \textit{derby.os3.nl.} zone must have at least two (for key management simplification) key-pairs published in the DNS, a Key Signing Key (KSK) and a Zone Signing Key (ZSK). They form the DNSKEY RRset of the zone. The ZSK is used to sign all the resource records in a zone. It is usually 1024 bits long and is roll-over more often than a KSK (every two weeks is common practise). The main reason for key-rollovers is that the longer a key is published, the higher is the probability that the key gets compromised by an attacker. A KSK is meant to validate the DNSKEY RRset. Since it is supposed to be roll-over less frequently than a ZSK, it is obvious that its size is bigger (most often 2048 bits). In addition, the KSK needs to be validated as well. To that end, the hash of the public key is published in the parent zone (\textit{os3.nl.} in our example) as a DS record. In other words, the KSK acts a Secure Entry Point (SEP) from the zone \textit{os3.nl.} to \textit{derby.os3.nl.}. Next, the same validation process occurs for the \textit{os3.nl.} zone, then for the \textit{nl.} zone to  finally reach the root zone. Any DNSSEC-capable resolver knows about the public portion of the root zone's KSK published by ICANN. This key acts as the trust anchor for DNSSEC resolvers.
\\
This chain can be broken if one of its link does not behave as it should. This is the reason why monitoring some of the elements mentioned above is essential for a DNSSEC zone's sake.           

